- 方法重载是构造器所必须的
- 带标签的break/continue的标签要紧挨着某个循环之前
- 方法重载时，及时参数类型相同，顺序不同，也不是同一个函数
- 因为存在忽略返回值调用，所以无法通过返回值来判断区分重载
- [容器类](https://blog.csdn.net/qq_37465368/article/details/80854672)
- java不能直接new基础类型，但是可以new基础类型的数组
- new数组的大小可以是变量，类似malloc
- Arrays.toString()
- dispose是清理函数，类似析构，但是不释放内存，能保证顺序，finalize释放内存，但是不保证顺序。
- 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
- [重装重写区别](https://www.runoob.com/java/java-override-overload.html)
- 判断是否需要进行继承，可以判断当前模型是否需要 向上转型，需要则可以使用继承，否则使用组合模式
- final int[] a = { 1, 2, 3 };//数组也是对象，所以支持引用的const
- final可以是运行时值
- final只要求使用前初始化，不是定义时初始化，所以有灵活性
- final方法可以防止继承时修改方法
- private的函数不会被子类覆盖改写，只是个重名函数罢了
- final类不可以被继承
- final关闭动态绑定
- 值域不会多态，静态方法不会多态
- 构造函数默认是static
- 构造函数里避免使用多态的函数，尽量只使用final的函数
- 多态允许返回有继承关系的函数
- 实现接口的方法必须是public的，
- interface里的值默认是static final,函数默认是public的
- interface可以嵌套，但是嵌套内部的interface不能为private,因为没法实现
- 接口和内部类组合可以生成完全隐蔽的类
- 内部类算是一种多重继承
- return new B(){};是一个匿名内部类的意思
- 接口实现回调函数机制，且能保证不像指针会被乱用
- 局部内部类比匿名内部类多了已命名的构造器，匿名内部类只能用实例初始化
- 每个类都有它自己的class文件，包括内部类和匿名类
- [finally+break，continue，return](https://www.cnblogs.com/bethunebtj/p/4676020.html)
- 只有与 finally 相对应的 try 语句块得到执行的情况下，finally 语句块才会执行。以上两种情况，都是在 try 语句块之前返回（return）或者抛出异常，所以 try 对应的 finally 语句块没有执行。
- 当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。
- finally 语句块应该是在控制转移语句之前执行，控制转移语句除了 return 外，还有 break 和 continue。另外，throw 语句也属于控制转移语句。虽然 return、throw、break 和 continue 都是控制转移语句，但是它们之间是有区别的。其中 return 和 throw 把程序控制权转交给它们的调用者（invoker），而 break 和 continue 的控制权是在当前方法内转移。
- 不能通过异常说明来重载函数
- 基类里的异常说明里的异常不一定会出现在子类里
- runtime exception和普通的异常的区别是普通异常是必检异常，runtime是可选异常，可以catch，不处理的话，编译器不会报错
- java不允许程序员重载操作符
- 使用super.toString()打印地址
- 有继承关系的类之间的class文件没有继承关系
- [各种数组包装类转换](https://blog.csdn.net/weixin_41615787/article/details/85115620)
- instanceof是表达式，不是利于和for循环结合，代码复杂，isInstance是class类的函数，可以跟type.class组合。
- java就设计了Class这个类.用于虚拟机对类的管理.当一个类被虚拟机装载完毕的时候,就会创建一个Class类
- [class loader 类加载机制](https://frank909.blog.csdn.net/article/details/54973413?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

