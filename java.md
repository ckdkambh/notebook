- 方法重载是构造器所必须的
- 带标签的break/continue的标签要紧挨着某个循环之前
- 方法重载时，及时参数类型相同，顺序不同，也不是同一个函数
- 因为存在忽略返回值调用，所以无法通过返回值来判断区分重载
- [容器类](https://blog.csdn.net/qq_37465368/article/details/80854672)
- java不能直接new基础类型，但是可以new基础类型的数组
- new数组的大小可以是变量，类似malloc
- Arrays.toString()
- dispose是清理函数，类似析构，但是不释放内存，能保证顺序，finalize释放内存，但是不保证顺序。
- 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
- [重装重写区别]（https://www.runoob.com/java/java-override-overload.html）
- 判断是否需要进行继承，可以判断当前模型是否需要 向上转型，需要则可以使用继承，否则使用组合模式
- final int[] a = { 1, 2, 3 };//数组也是对象，所以支持引用的const
- final可以是运行时值
- final只要求使用前初始化，不是定义时初始化，所以有灵活性
- final方法可以防止继承时修改方法
- private的函数不会被子类覆盖改写，只是个重名函数罢了
- final类不可以被继承
- final关闭动态绑定
- 值域不会多态，静态方法不会多态
- 构造函数默认是static
- 构造函数里避免使用多态的函数，尽量只使用final的函数
- 多态允许返回有继承关系的函数
- 实现接口的方法必须是public的，
- interface里的值默认是static final,函数默认是public的
- interface可以嵌套，但是嵌套内部的interface不能为private,因为没法实现
- 接口和内部类组合可以生成完全隐蔽的类
- 内部类算是一种多重继承
- return new B(){};是一个匿名内部类的意思
- 接口实现回调函数机制，且能保证不像指针会被乱用
- 
