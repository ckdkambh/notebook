- 方法重载是构造器所必须的
- 带标签的break/continue的标签要紧挨着某个循环之前
- 方法重载时，及时参数类型相同，顺序不同，也不是同一个函数
- 因为存在忽略返回值调用，所以无法通过返回值来判断区分重载
- [容器类](https://blog.csdn.net/qq_37465368/article/details/80854672)
- java不能直接new基础类型，但是可以new基础类型的数组
- new数组的大小可以是变量，类似malloc
- Arrays.toString()
- dispose是清理函数，类似析构，但是不释放内存，能保证顺序，finalize释放内存，但是不保证顺序。
- 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
- [重装重写区别](https://www.runoob.com/java/java-override-overload.html)
- 判断是否需要进行继承，可以判断当前模型是否需要 向上转型，需要则可以使用继承，否则使用组合模式
- final int[] a = { 1, 2, 3 };//数组也是对象，所以支持引用的const
- final可以是运行时值
- final只要求使用前初始化，不是定义时初始化，所以有灵活性
- final方法可以防止继承时修改方法
- private的函数不会被子类覆盖改写，只是个重名函数罢了
- final类不可以被继承
- final关闭动态绑定
- 值域不会多态，静态方法不会多态
- 构造函数默认是static
- 构造函数里避免使用多态的函数，尽量只使用final的函数
- 多态允许返回有继承关系的函数
- 实现接口的方法必须是public的，
- interface里的值默认是static final,函数默认是public的
- interface可以嵌套，但是嵌套内部的interface不能为private,因为没法实现
- 接口和内部类组合可以生成完全隐蔽的类
- 内部类算是一种多重继承
- return new B(){};是一个匿名内部类的意思
- 接口实现回调函数机制，且能保证不像指针会被乱用
- 局部内部类比匿名内部类多了已命名的构造器，匿名内部类只能用实例初始化
- 每个类都有它自己的class文件，包括内部类和匿名类
- [finally+break，continue，return](https://www.cnblogs.com/bethunebtj/p/4676020.html)
- 只有与 finally 相对应的 try 语句块得到执行的情况下，finally 语句块才会执行。以上两种情况，都是在 try 语句块之前返回（return）或者抛出异常，所以 try 对应的 finally 语句块没有执行。
- 当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。
- finally 语句块应该是在控制转移语句之前执行，控制转移语句除了 return 外，还有 break 和 continue。另外，throw 语句也属于控制转移语句。虽然 return、throw、break 和 continue 都是控制转移语句，但是它们之间是有区别的。其中 return 和 throw 把程序控制权转交给它们的调用者（invoker），而 break 和 continue 的控制权是在当前方法内转移。
- 不能通过异常说明来重载函数
- 基类里的异常说明里的异常不一定会出现在子类里
- runtime exception和普通的异常的区别是普通异常是必检异常，runtime是可选异常，可以catch，不处理的话，编译器不会报错
- java不允许程序员重载操作符
- 使用super.toString()打印地址
- 有继承关系的类之间的class文件没有继承关系
- [各种数组包装类转换](https://blog.csdn.net/weixin_41615787/article/details/85115620)
- instanceof是表达式，不是利于和for循环结合，代码复杂，isInstance是class类的函数，可以跟type.class组合。
- java就设计了Class这个类.用于虚拟机对类的管理.当一个类被虚拟机装载完毕的时候,就会创建一个Class类
- [class loader 类加载机制](https://frank909.blog.csdn.net/article/details/54973413?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)
- 反射机制，可以绕过private封装的方法和接口封装的类，但是对final值域没有影响
- 泛型只有在赋值语句里才能自动类型推导，其他，比如参入传入，可以用.<>的语法指定泛型函数入参类型
- < extends T>是为了解决擦除问题
- 泛型类型只有在静态类型检查期间才出现。再此之后会被擦除成他的非泛型上界
- 擦除为了解决泛型和非泛型兼容
- 边界定义中的&，只能用于声明模板，不能用于定义模板，比如，List<? extends SuperHearing & SuperSmell> dogBoys;是非法的
- List<? extends Frut> 表示 “具有任何从Fruit继承类型的列表”，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象。可以添加null,因为null 可以表示任何类型。所以List 的add 方法不能添加任何有意义的元素，但是可以接受现有的子类型List<Apple> 赋值。也就是List<? extends Frut>语法是为了赋值别的List
- List<? super Fruit> 表示“具有任何Fruit超类型的列表”，列表的类型至少是一个 Fruit 类型，因此可以安全的向其中添加Fruit 及其子类型。由于List<? super Fruit>中的类型可能是任何Fruit 的超类型，无法赋值为Fruit的子类型Apple的List<Apple>.List<? super Fruit>语法是为了实例化一个List，里面可以像正常的List一样操作
- extends 可用于的返回类型限定，不能用于参数类型限定。super 可用于参数类型限定，不能用于返回类型限定。带有super超类型限定的通配符可以向泛型对易用写入，带有extends子类型限定的通配符可以向泛型对象读取。
- [java泛型关键字理解](https://www.cnblogs.com/hf-cherish/p/4387662.html)
- List表示持有任何Object类型的原生List，其实就等价于List<Object>，List<?>表示某种具有特定类型的非原生List(同构集合)，只是我们不知道它的具体类型是什么，所以我们就不允许往里set数据
- [自限定类型](https://www.cnblogs.com/allmignt/p/12353745.html)
- [泛型](https://www.cnblogs.com/coprince/p/8603492.html)
- 泛型主要解决编译时期就能发现问题
